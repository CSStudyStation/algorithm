折木棍

题目描述
在你的面前从左到右摆放着 n 根长短不一的木棍，你每次可以折断一根木棍，并将折断后得到的所有新木棍放在原来的位置。
折断后得到的所有新木棍的长度必须为整数，且它们之和等于折断前的木棍长度。最终你希望从左到右的木棍长度单调不减，那么你至少需要折断多少次？

示例：
输入：[3, 5, 13, 9, 12]
输出：1

输入：[3, 12, 13, 9, 12]
输出：2

输入：[3, 13, 12, 9, 12]
输出：3

输入：[3, 13, 60, 7]
输出：10

输入：[3, 63, 7]
输出：8

输入：[9, 1]
输出：8

分析：
对于测试用例 [3, 13, 60, 7],
因为 60 折成的数字 <= 7，所以有 60 / 7 = 8 余 4，即 60 可以分为 8 个数字(7, 7, 7, 7, 7, 7, 7, 7) 余 4，
即 60 需要折断 8 次分为 9 个数字才能满足题意。
60 / 9 = 6 余 6，即 60 可以分为 9 个数字(6, 6, 6, 6, 6, 6, 6, 6, 6) 余 6，所以可转化为 (6, 6, 6, 7, 7, 7, 7, 7, 7) 


// Time Complexity: O(n)
// Space Complexity: O(1)
class Solution {
public:
    int breakNum(vector<int>& nums) {
        int count = 0;
        unsigned long len = nums.size();
        for (int i = len - 2; i >= 0; i--) {     // 例如：[3, 13, 60, 7]
            if(nums[i+1] >= nums[i]) 
                continue;
            
            // 对 nums[i] 进行折断
            int n = (nums[i] - 1) / nums[i+1];
            count += n;
            
            nums[i] = nums[i] / (n+1);
        }

        return count;
    }
};



